\documentclass[12pt]{article}

\usepackage[english]{babel}
\usepackage{amsmath, amsfonts, amsthm}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multicol}
\usepackage{titleps}
\usepackage{hyperref}
\usepackage{caption}
%\usepackage[a4paper, left=1in, right = 1in, top = 1in, bottom = 1in]{geometry}

%Ширина таблицы
\setlength\tabcolsep{16pt}

%СТРОКИ
\linespread{1}
\setlength{\parindent}{0 pt}
\setlength{\parskip}{6pt}

%Начало
\begin{document}

\pagenumbering{arabic}
\tableofcontents
\newpage

\section{Automated synthesis of test programs for diagnosis of microcircuits and memory modules}
\subsection{Application of directed graphs for parallelizing micro-operations in test algorithms}  

\vspace{3mm}
A directed graph $G=(A,B)$, containing n vertices and m arcs, can be represented as an incidence matrix $M$, the elements of
which are defined as follows: $a_{i,j} = 1$ if arc $j$ leaves vertex $i$; $a_{i,j} = -1$, if arc $j$ approaches vertex $i$ or there is a loop at vertex $i$; $a_{i, j} = 0$ if arc $j$ does not have a common point with vertex $i$. Let an incidence matrix $M$ of size $n*m$ elements be given:\newline

{\centering
$M =
\begin{matrix}a_{0,0}&a_{0,0}&
\begin{matrix}\dots{}&a_{0,0}\end{matrix}\\a_{0,0}&a_{0,0}&
\begin{matrix}\dots{}&a_{0,0}\end{matrix}\\
\begin{matrix}\dots{}\\a_{0,0}\end{matrix}&
\begin{matrix}\dots{}\\a_{0,0}\end{matrix}&
\begin{matrix}\begin{matrix}\dots{}\\\dots{}\end{matrix}&
\begin{matrix}\dots{}\\a_{0,0}\end{matrix}\end{matrix}
\end{matrix}$
\par}
\vspace{4mm}
\[x = \frac{-b\pm \sqrt{b^2 - 4ac}}{2a}\]

\noindent
It is required to split it into k matrices of size (n*m/k) each. To solve this problem, we perform the following transformations:

\vspace{-15pt}
{\centering
 \[\forall p \{ 0,1,...,k - 1\} : = 1 ,\in\rightarrow a_{00}^{M_p}\
\]}   

\noindent where \  $a_{i,r+1}^{M_0}${}- matrix element;

k – number.

It is possible to parallelize or combine the operation algorithms of individual generators into a common test algorithm.

\subsection{Method for designing UY-circuits of diagnostic algorithms for high-speed storage devices}\newpage

When using the method of parallelizing micro-operations in test algorithms, performance increases and requirements are reduced.

\subsection{Methods and program for selecting an effective set of tests for diagnosing storage devices}

The high time required to perform test diagnostics of large-capacity RAM determines the problem of selecting effective
tests that cover the most likely faults [30]. In a formalized form, the problem of selecting tests can be represented
as the following functional [3, 7, 9]:

\vspace{4pt}
{\centering
$F = {\langle} T, P, M{\rangle} $,
\par}

where $T$ is the duration of testing; 

$P$ – probability of fault coverage; 

$M$ – number of tests.

{\selectlanguage{english}
This functionality allows you to create seven tasks that are of practical importance and are given in Table \ref{memory} and
allow you to select a strategy for adaptive diagnostics of microcircuits and memory modules. }


\captionsetup[table]{skip=0pt,singlelinecheck=off}
\begin{table}[h!]
\caption{Memory module diagnostic tasks}
\label{memory}
\begin{center} 
    \def\arraystretch{1.2}
    \begin{tabular}{|c|c|c|c|c|}
        \hline
        No. & $T$ & $P$ & $M$ & Functions \\
        \hline
        1 & var & var & var & $P = f(T, M)$\\
        \hline
        2 & var & const & var & $P = f(T, M)$\\
        \hline
        3 & var & const & var & $P = f(T, M)$\\
        \hline
        4 & const & var & var & $P = f(T, M)$\\
        \hline
        5 & const & var & var & $P = f(T, M)$\\
        \hline
        6 & var & var & const & $P = f(T, M)$\\
        \hline
        7 & var & var & const & $P = f(T, M)$\\
        \hline
        \end{tabular}
    \end{center}
\end{table}

Let us consider in more detail the description of these problems [37,75].

\begin{enumerate}
\item $P = f(T, M)$ – is the task of determining the probability of fault \mbox{coverage} without limiting the time and number of tests. It does not have a formalized solution, since there are a large number of combinations of different sequences of
tests used.\newline
\item $M = f(T, P = const)$ – defines an optimized set of tests that ensure the achievement of a given probability of fault coverage. The testing time is not limited.\newline
\item $T = f(P = const, M)$ – determines the minimum time during which the most favorable sequence of tests ensures the specified probability of fault coverage.\newline
\item $P = f(T = const, M)$ – determines the maximum possible probability of fault coverage when limiting the testing duration by enumerating all possible sequences of test execution.\newline
\item $M = f(T = const, P)$ – defines the minimum set of tests that provide the highest possible probability of fault coverage while limiting the testing duration.\newline
\item $T = f(P, M=const)$ – determines the number of test repetitions $M$, which will ensure the highest possible probability of fault coverage. Typically, this testing strategy is wiped out when testing the reliability of memory modules.
\end{enumerate}

When performing test diagnostics of memory modules at early stages of the life
cycle, it is advisable to use two testing strategies:

Lists are easy to create:
\begin{itemize}
  \item Selection of an optimized test sequence based on the knowledge of diagnostic experts;
  \item Minimizing the test set through the use of heuristic and fuzzy algorithms.
\end{itemize}

In a similar way, you can obtain normalized values for all assessments of test properties according to given criteria and present them in the form of a \raggedright {Table  \ref{memory}.} For each criterion, you can obtain its average value using the formula:

\[E_{sr}^j = \sum_{i=1}^n E_{ij} / k\]
\newpage
\section{Methodology for designing fail-tolerant storage devices}
\subsection{Structure of built-in self-testing tools for memory chips}  

Built-in Self Test, or BIST (built-in Self Test), is a method of designing additional hardware and software that can perform self-testing, that is, testing their own device operation (functionally, parametrically, or a combination of both), using proprietary circuitry that reduces dependence on external automated test equipment (ATE) [11, 40].

\subsection{The use of digital machines for building built-in self-testing tools}

First, counters k and l are set to zero, then the starting address of the array of memory cells is selected, the code of two-dimensional Walsh functions is entered into the control data register, and information is written to the selected cell. The value of the current address register is increased by one and codes are written to all memory cells in the same way. Figure \ref{figure_1} show this.

\begin{figure}[h]
    \centering
    \includegraphics{image_1.png}
    \caption{Memory chip self-testing algorithm}
    \label{figure_1}
\end{figure}

\subsection{Design of firmware built-in self-test tools}

A wide variety of self-tests can be generated using the microprogram principle of controlling the hardware built into the memory chip [75].

In Figure \ref{figure_2} shows the structure of a semiconductor memory chip with built-in self-testing tools.

\begin{figure}[h]
    \centering
    \includegraphics[width = 120mm]{image_2.png}
    \caption{Structure of a semiconductor memory chip with built-in self-testing \centering{tools}}
    \label{figure_2}
\end{figure}

\newpage
\section{Conclusion}

The complexity of developing algorithms and test programs for verifying memory chip models is significantly reduced if they are developed in the machine-oriented programming language Prover, which takes into account the structural features of the diagnosed semiconductor memory chips


The proposed method for verifying VHDL models of memory chips has the following advantages over similar developments:

\begin{itemize}
  \item {The process of recording and comparing read data with reference values is automated;}
  \item An algorithmic method of generating tests is used,
  \item Test programs previously developed in the Prover language are used, which reduces the complexity of their design and provides an easier way to localize errors in model programs and tests;
\end{itemize}

\end{document}